![NHN Cloud_meetup banner_voicefishing_202406-02-01](https://github.com/jungparc/meetup/assets/107228890/b754b1ae-34fa-4fe1-be74-79729181cb4d)
# 보이스 피싱 애플리케이션 분석 2부 (完)

* 안녕하세요. NHN Cloud 서비스보안팀 지우중입니다.
* 많은 분들이 보이스 피싱 애플리케이션 분석 1부를 재밌고 흥미롭게 읽어주셔서 빠르게 2부를 준비했습니다.
* 보이스 피싱 애플리케이션 분석 2부에서는 보이스 피싱 애플리케이션에서 어떤 데이터를 C&C서버(*Command & Control Server:* *해커가 공격을 수행하기 위해 제어하는 서버*)로 보내는지, 피해자 단말기에서는 어떤 일이 일어나는지 알아보려고 합니다.
* 또한, 보이스 피싱 애플리케이션의 핵심인 전화 가로채기, 오디오 도청, 위치 추적(GPS), 불법 촬영, SMS 탈취에 대한 분석 내용을 공유하려고 합니다.
* 그럼, 바로 보이스 피싱 애플리케이션 분석 2편 시작하겠습니다!

***

# 피해자 단말기 등록

* 먼저, 결론부터 말씀드리자면 보이스 피싱 애플리케이션에서는 피해자 단말기에서 지속적인 모니터링 및 제어 등을 하기 위해 피해자 단말기를 등록하는 과정이 필요합니다.
* 보이스 피싱 애플리케이션을 설치한 후 실행하자마자 발생하는 패킷[[1]](https://developer.mozilla.org/ko/docs/Glossary/Packet)을 분석하면, 서버에 피해자의 단말기 정보를 전송하면서 등록 절차를 완료하는 것을 확인할 수 있습니다.
* 이 과정에서 피해자의 전화번호, 통신사, 단말기 정보 등이 포함된 데이터가 전송되는 것을 확인할 수 있었습니다.
* 피해자 단말기를 등록하는 패킷은 아래와 같이 POST 형식으로 [http://137.220.230.51/17](http://137.220.230.51/17) 으로 postVal이라는 값을 전송하는 것을 볼 수 있습니다.
* {Image}
* 패킷 내용을 보시면 postVal의 값은 평문이 아닌 알 수 없는 값을 C&C 서버로 전송하는 걸 알 수 있습니다.
* 하지만 분석하는 입장에서는 정확히 postVal의 값이 어떤 내용인지 알아야 합니다.
* 그 이유는 보이스 피싱 범죄자들 입장에서는 postVal 값이 어떤 목적으로 서버로 보내는지 알고 있겠지만 분석하는 입장에서는 평문의 postVal 값을 알아야만 애플리케이션을 실행하자마자 postVal 값을 서버로 보내는 이유를 추측할 수 있기 때문입니다.
* 따라서 postVal 값이 어떻게 생성되는지 그 위치를 찾을 필요가 있습니다.
* 분석한 결과, 아래의 코드가 해당 패킷을 생성하는 코드로 확인되었습니다.
* {Image}
* 위의 코드에서 ①번을 자세히 살펴보겠습니다.
* {Image}
* reqBody란 request 패킷의 body 부분을 의미합니다.
* 즉, 서버로 요청하는 실제 데이터가 존재하는 영역이라고 생각하시면 됩니다.
* 코드를 분석하면, s5라는 값은 ②번에서 만들어지며 s4는 ③번에서 만들어지는 것을 알 수 있습니다.
* ③번을 통해서 서버로 보낼 데이터의 형식은 JSON[[2]](https://namu.wiki/w/JSON)으로 보내는 것을 확인할 수 있으며 변수 s4의 값은 아래의 a.b() 메서드에서 반환된 값을 의미합니다.
* {Image}
* 따라서 변수 s4의 값을 확인하기 위해서는 a.b() 메서드를 살펴볼 필요가 있습니다.
* {Image}
* a.b() 메서드를 확인한 결과, AES/CBC/PKCS5Padding[[3]](https://namu.wiki/w/AES) 알고리즘을 사용하며 key는 "rb!nBwXv4C%Gr^84", IV[[4]](https://ko.wikipedia.org/wiki/%EC%B4%88%EA%B8%B0%ED%99%94_%EB%B2%A1%ED%84%B0)값은 "1234567812345678"을 사용하는 것을 확인할 수 있습니다.
* 즉, 어떤 값을 암호화하여 최종적으로 Base64 인코딩[[5]](https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464)을 수행한 후 반환하고 있는 것을 알 수 있습니다.
* 따라서 암호화를 수행하기 전 평문값을 알 수 있다면 보이스 피싱 범죄자들에게 어떤 데이터를 보내는지 알 수 있습니다.
* 여기에는 2가지 방법이 있습니다.
* 첫 번째로는 a.b() 메서드를 후킹(*프로그램에서 구성 요소 간에 발생하는 함수 호출, 메시지, 이벤트 등을 중간에서 바꾸거나 가로채는 명령, 방법, 기술이나 행위*)하여 cleartext라는 인자값을 출력하는 방법과 두 번째로는 암호화된 값을 복호화하는 방법이 있습니다.
* 위의 그림에서 보셨다시피 암호화 과정에 사용한 암호화 알고리즘은 AES 암호화로 대표적인 대칭키 암호화 알고리즘입니다.
* 대칭키 암호화의 가장 큰 특징은 암호화와 복호화를 할 때 사용하는 Key와 IV 값이 같다는 점입니다.
* 따라서 Key와 IV 값이 노출되었기 때문에 두 번째 방법을 이용하면 다음과 같이 평문의 데이터를 확인할 수 있습니다.
* {Image}
* 위의 값을 추측해 보면 app_id는 보이스 피싱 애플리케이션을 만든 조직에서 부여한 값인 것으로 추측됩니다.
* pid 값은 해당 단말기의 Google 계정과 관련된 값으로 보이며 나머지 값은 피해자 단말기의 정보라고 보시면 됩니다.
* 여기서 왜 app_id가 17이지? 라는 생각이 들 수도 있는데요.
* 보이스 피싱 범죄자들은 1개의 보이스 피싱 애플리케이션을 만드는 것이 아니라 조직적으로 대량의 악성 애플리케이션을 만듭니다.
* 쉽게 예를 들자면, 보이스 피싱 애플리케이션 및 악성 애플리케이션 100개를 만들어 배포한 후 app_id가 없으면 관리적인 측면에서 어떤 악성 애플리케이션에서 요청한 패킷인지 관리하기가 힘들어집니다.
* {Image}
* 따라서 위의 그림처럼 각 애플리케이션에 app_id를 부여한 후 app_id 번호에 맞게 서버를 구성한다든지, 피해자들을 속이기 위한 보이스 피싱 시나리오 등 관리 및 기타 목적으로 app_id를 부여한 것으로 추측됩니다.
* 범죄자들은 자신의 서버에서 피해자가 자신들이 만든 보이스 피싱 애플리케이션이 설치된 후 단말기 등록 패킷을 기다린 후 app_id와 휴대폰 번호(p_no) 등을 보고 자신들이 정한 시나리오 및 목적에 따라 피해자들을 속이기 시작합니다.
* 즉, 빠르게 피해자들을 속이기 위해 필요한 데이터라고 생각해 주시면 될 것 같습니다.
* 여기서 말하는 시나리오란 [이 영상](https://www.youtube.com/watch?v=eapWmmBFK6s&t=533)을 참고하시면 쉽게 이해가 될 것 같습니다.
* 하지만 분석 과정에서 단말기 등록 패킷이 발생한 후 C&C 서버에서는 아무런 응답이 오지 않았습니다.
* 그 이유는 보이스 피싱 조직들은 C&C 서버를 일정 기간 운영한 후 이전 및 폐쇄하는 경향이 있는데 현재 분석하는 보이스 피싱 애플리케이션의 C&C 서버도 마찬가지로 이전 및 폐쇄한 것으로 보입니다.
* 사실 이 부분이 분석하는 과정에서 가장 아쉬운 부분이었습니다.
* 실제로 동작하는 C&C 서버였다면 실시간으로 데이터를 주고받으면서 정확하게 분석할 수 있었지만 이렇게 서버와의 통신이 없다면 사실 완벽한 분석은 어렵다고 볼 수 있습니다.
* 하지만 최대한 해당 보이스 피싱 애플리케이션의 특징을 분석해 보고자 노력하였습니다.

# 화면 분석

## 1. APK 추가 설치

* 분석 당시 저는 'C&C 서버에서 응답이 없어 이제 어떻게 분석을 진행해야 하지?' 라는 생각과 함께 아래의 애플리케이션 첫 화면을 보면서 고민에 빠져있었습니다.

* {Image}
* 고민하던 도중 '잠시만.. C&C 서버에서 응답이 없었는데 지금 내가 보고 있는 화면은 뭐지? 어디서 보내준 거지?' 라는 생각이 문득 들었습니다.
* 그래서 바로 다시 네트워크 패킷을 분석하였습니다.
* 하지만 어떤 패킷에서도 해당 화면에 대한 데이터는 존재하지 않았습니다.
* 통신 구간이 아니면 남아 있는 것은 APK 파일밖에 없습니다.
* 그래서 다시 APK 파일을 추가로 분석하였습니다.
* APK 파일을 분석하던 도중 assets 디렉토리에 다음과 같은 파일이 존재했습니다.
* {Image}
* assets 디렉토리에 존재하는 MP3 파일을 재생해 보면 금융 위원회, 검찰청 민원 상담실, 금감원 콜센터에 전화하면 들리는 안내 음성 파일들이었습니다.
* 위의 MP3 파일은 전화 가로채기 수법에 활용되며 피해자를 속이기 위한 파일임을 추측할 수 있었습니다.
* 또한 MP3 파일 이외 plbFhm.apk, uSBxbR.apk 파일이 존재했습니다.
* 이는 해당 보이스 피싱 애플리케이션에서 사용하고 있는 또 다른 APK 파일이라는 것을 확인할 수 있었는데요.
* 하지만 마지막으로 남은 tspTFl.sz 파일은 어떤 파일인지 알 수 없었습니다.
* 주로 `.sz` 확장자는 압축된 파일 형식 중 하나입니다.
* 압축된 파일이 맞는지 확인하기 위해 Hex Editor로 해당 파일을 열어 보았습니다.
* {Image}
* 다행스럽게도 PK 파일 포맷[[7]](https://namu.wiki/w/%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98)으로 되어있는 것을 확인하였으며 파일 자체로는 암호화가 되어있지 않았습니다.
* 이 tspTFl.sz 파일을 열어보기 위해 확장자를 `. zip`으로 변경 후 파일을 열어보았습니다.
* {Image}
* 열어본 결과 html 파일과 js 폴더, 알 수 없는 폴더가 존재하였습니다.
* 어떤 파일인지 분석을 진행하기 위해 압축 풀기를 수행하였지만, 다음과 같이 패스워드가 설정되어 있었습니다.
* {Image}
* 패스워드가 설정된 것으로 보아, 중요한 파일인 것 같았는데요.
* 이 패스워드를 분석하기 위해 APK 파일 분석을 진행하였습니다.
* 분석한 결과, 아래의 그림처럼 패스워드는 “s*******a”로 하드코딩 되어 있었으며 발견된 패스워드로 압축 파일을 해제할 수 있었습니다.
* {Image}
* 압축이 풀린 html 파일을 열어보면 애플리케이션의 첫 화면인 것을 알 수 있었습니다.
* {Image}
* 위의 결과로 C&C 서버에서 화면 데이터를 받아오지 않아도 첫 화면을 볼 수 있었던 이유를 알아냈습니다.
* 또한 ivrvyeuimagesivrvyeu 디렉토리에는 상담원으로 예상되는 사진 파일(도용된 사진으로 추측됩니다)과 애플리케이션의 화면을 구성하는 그림 파일들이 저장된 것을 확인할 수 있었습니다.
* {Image}
* 그래도 아쉬운 마음에 '다른 메뉴를 클릭하면 다른 C&C 서버가 동작하지 않을까?' 생각을 해서 아래의 **대출 승인 사례** 메뉴를 클릭해 보았습니다.
* {Image}
* 위 그림에서 보시는 것처럼 **대출 승인 사례**를 클릭하자 다음과 같은 알림이 발생했습니다.
    * `금융상품을 만드는건 어렵지만 불필요한 과정을 찾아 알기위하여 간편한 모바일로 알기쉽게 설계했다.(그림 1)`
    * `보안상 새로운 업데이트가 있습니다. 새버전을 설치해시기 바랍니다.(그림 2)`
    * 알림 문구도 어딘가 어색해 보이는 게 한국에서 만든 애플리케이션이 아닌 것을 추측할 수 있습니다.
* 이러한 문구는 또 다른 악성 애플리케이션의 설치를 유도하는 전형적인 악성 애플리케이션의 특징 중 하나입니다.
* 앞에서 살펴보았던 assets 디렉토리에 존재하는 plbFhm.apk 파일을 설치하도록 유도하는 문구였습니다.
* {Image}
* 이렇게 애플리케이션을 설계한 이유는 간단합니다.
* 제일 먼저 설치하는 애플리케이션에서 모든 악성 행위를 수행한다면 쉽게 분석이 가능하기 때문에 탐지와 분석을 힘들게 하기 위함입니다.
* plbFhm.apk 파일을 대략적으로 정리하자면 암호화된 DEX 파일 2개와 총 5개의 MP3 파일이 존재합니다.
 * {Image}
* 암호화된 DEX 파일이 존재하는 이상 plbFhm.apk도 분석하기 위해서는 암호화된 DEX 파일은 복호화해야 합니다.
* 이 과정은 1편에서 자세히 소개해 드렸기 때문에 2편에서는 넘어가도록 하겠습니다.
* 조금 더 자세한 분석을 진행하기 위해 plbFhm.apk를 설치해 보았습니다.
* 설치하는 순간 수많은 Permission(권한)을 요구하는 것을 볼 수 있습니다.
* 예를 들어, 문자(SMS), 연락처, 사진, 동영상, GPS 등 사생활과 밀접하게 연관된 권한을 요구하는데요.
* {Image}
* 그렇다면 이렇게 많은 권한을 요구하는 이유가 무엇일까요?
* 당연히 악성 행위를 하기 위함입니다.
* 그렇다면 왜 이렇게 민감한 권한이 필요한지를 알아보기 위해 위 권한 모두 사용을 허용해 줍니다.
* 그 후 다시 하단의 **대출 승인 사례** 메뉴 버튼을 클릭해 봅니다.
* {Image}
* {Image}
* 이번에는 보안 업데이트가 존재한다면서 또 다른 악성 애플리케이션 설치를 유도합니다.
* uSBxbR.apk도 plbFhm.apk 파일처럼 암호화된 DEX 파일 2개와 총 3개의 MP3 파일이 존재하였으며 해당 APK 파일도 똑같이 암호화된 DEX 파일을 복호화한 후 분석을 진행하였습니다.
* 자 여기까지 복잡하실 수 있는데 아래의 그림으로 다시 한번 정리해 드리겠습니다.

* {Image}
* 위의 그림을 설명해 드리자면 Base.apk(껍질) 즉, 처음으로 설치하고 실행하는 APK 파일은 핵심이 아닌 껍질을 의미합니다.
* 그 후 2개의 진주(핵심)는 추가로 설치한 2개의 APK 파일이라고 생각하시면 됩니다.
* 즉, 보이스 피싱 애플리케이션의 핵심 모듈 및 악성 행위를 하는 코드들은 2개의 진주(핵심)에 존재했으며 2개의 진주(APK)가 보이스 애플리케이션의 핵심이라고 생각하시면 됩니다.

## 2. 상담 내용 작성

* 위에 추가로 설치한 2개의 APK 파일 설치가 끝난 후에 아래의 **대출 승인 사례**를 클릭해 보면 피해자들을 속이기 위해 실제 **대출 승인 사례**를 보여주는 것을 확인할 수 있습니다.
* {Image}
* 당연히 실제로는 존재하지 않는 사례들입니다.
* 위의 메뉴에서의 핵심은 **상담 신청하기** 메뉴인 것으로 확인되었습니다.
* {Image}
* 아래와 같이 상담 신청 내용을 작성하기 위해 **신청하기**를 클릭해 봅니다.
* {Image}
* 상담에 필요한 기본적인 정보를 입력하고 **신청하기** 버튼 클릭 후 신청 완료로 최종적으로 상담 신청을 완료합니다.
* 그렇다면 이제 어떻게 될까요?
* 위에서 입력한 상담에 필요한 정보는 user_info라는 파일 이름으로 악성 애플리케이션 내부 저장소에 저장됩니다.
* {Image}
* user_info 파일을 열어보면 다음과 같이 아까 상담 신청에서 입력한 정보가 저장된 것을 알 수 있습니다.
* {Image}
* 위의 정보 마지막에 gongzuo, nianxin, edu, dizhi이라는 알 수 없는 단어가 존재하였습니다.
* 그대로 발음 해보니 중국어와 비슷하여 검색해본 결과 다음과 같았습니다.
* {Image}
* 따라서 해당 보이스 피싱 애플리케이션은 중국에서 만들어졌다는 것을 알 수 있었습니다.
* 정리해 보면, **상담 신청**이라는 메뉴의 목적은 'user_info'라는 파일을 생성하여 해커가 원하는 대출 금액, 연봉, 직업 등의 정보를 획득하기 위한 목적이었음을 알 수 있습니다.

# Permission 이란

* 위에서 잠깐 언급하였지만 Permission(권한)이라는 개념에 대해 짧게나마 설명하고 넘어가 보도록 하겠습니다.
* Android와 iOS에서는 애플리케이션을 설치할 때 설치된 단말기의 특정 기능이나 정보에 접근하기 위해 사용자로부터 허락을 받아야 하는 메커니즘이 필수인데요.
* 여러분이 사용하는 단말기에서 애플리케이션을 설치할 때 아래의 그림을 한 번쯤은 보셨을 겁니다.
* {Image}
* 이렇게 애플리케이션에서 사용할 권한을 사용자에게 알려주고 허락을 구하는 메커니즘이라고 생각하시면 됩니다.
* 그럼 이런 권한은 어디에 정의되어 있을까요?
* 바로 Androidmanifest.xml[[8]](https://developer.android.com/guide/topics/manifest/manifest-intro?hl=ko)에 정의되어 있습니다.
* 아래 목록은 실제 분석 중인 보이스 피싱 애플리케이션의 Androidmanifest.xml에 정의되어 있는 권한 중 일부입니다.
* {Image}
* 이제 왜 이런 권한을 요구하는지, 권한을 허용하면 어떤 일이 발생하는지, 보이스 피싱 애플리케이션에서 주로 사용되는 오디오 도청, 위치(GPS), 사진과 동영상, 발신 전화 경로 전환, SMS 접근 총 5개의 권한에 대해서 자세히 살펴보도록 하겠습니다.

# 보이스 피싱 애플리케이션의 5가지 악성 행위

* 보이스 피싱 애플리케이션을 분석하면서 정말 다양한 악성 행위가 있다는 것을 느꼈습니다.
* 기사와 영상으로 보는 것보다 직접 구현해 보고 테스트를 해보면서 바뀐 생각이 '보이스 피싱을 왜 당할까?'라는 생각은 사라지고 '아, 이 정도면 진짜 당할 수도 있겠구나'라고 생각이 바뀌었습니다.
* 이렇게 제 생각이 바뀐 이유는 총 5개였습니다.
* 보이스 피싱 애플리케이션에서 오디오 도청, 위치 추적, 사진 및 동영상 불법 촬영, 발신 전화 경로 전환, SMS 탈취 총 5개의 권한에 접근하였으며 해당 권한에 접근할 수 있다면 1편에서 잠깐 소개해 드렸던 영화 보이스와 스마트폰을 떨어뜨렸을 뿐인 데의 영화 속 피해자들처럼 삶이 붕괴하기까지는 정말 시간 문제인 것 같았습니다.
* 따라서 위의 5개의 권한에 대해서 자세히 알아보도록 하겠습니다.

## 1. 오디오 도청

* 오디오를 녹음하기 위해서는 다음과 같은 권한이 필요합니다.
* {Image}
* 위의 권한을 사용하는 곳을 분석한 결과 아래의 코드처럼 /sdcard/에 log라는 디렉토리에 MP4라는 파일 형식으로 녹음된 파일이 저장되는 것을 알 수 있습니다.
* {Image}
* 위에서 저장소 위치가 SD_CARD이기 때문에 SD 카드 권한이 필요한 것입니다.
* {Image}
* 그럼, 언제 위의 권한을 사용하는 걸까요?
* 바로 통화할 때 RECORD_AUDIO 권한을 사용해서 통화 내용을 녹음합니다.
* 피해자가 수신 또는 발신을 하면 보이스 피싱 범죄자들이 가지고 있는 전화번호 리스트에서 수신지와 발신지 전화번호를 체크합니다.
* 해당 리스트에 수신지 또는 발신지의 번호가 존재하면 그때부터 녹음이 시작된다는 의미입니다.
* 즉, 어디로 전화를 거는지 또는 어디에서 전화를 받는지 알 수 있으며 어떤 목적으로 통화한 것인지 다 알 수 있다는 의미입니다.
* 그럼, 전화번호 리스트는 어떻게 관리되고 있을까요?
* 분석 결과 아래의 코드처럼 전화번호는 C&C 서버에서 실시간으로 업데이트되는 것을 알 수 있었습니다.
* {Image}
* 또한, 녹음된 통화 파일은 아래의 코드처럼 `http://137.220.230.51/101` 파일을 전송하는 것을 알 수 있었습니다.
* {Image}
* 여기서 조금만 다르게 생각을 해봅시다.
* 현재 도청과 감청의 기술은 엄청나게 발달했다고 합니다.
* 위의 내용과 함께 생각해 보면 우리 모두가 일상생활 중 항상 들고다니는 큰 도청기가 있습니다.
* 바로 휴대전화입니다.
* 위의 방법은 보이스 피싱 범죄를 위한 애플리케이션으로 만들어진 보이스 피싱 애플리케이션입니다.
* 그렇기 때문에 통화 녹음에 대한 기능만 존재했습니다.
* 근데 만약 보이스 피싱 애플리케이션이 아니라면 어떤 사태가 발생할까요?
* 바로 위에서 말씀드렸던 악성 애플리케이션이 설치된 단말기가 하나의 큰 도청기가 되는 것입니다.
* 이를 조금 더 이해하기 쉽게 데모 영상을 짧게 만들어봤습니다.
* 데모 영상을 보시기 전에 먼저 말씀드리자면 왼쪽이 악성 애플리케이션에 설치된 피해자의 단말기입니다.
* 오른쪽이 해커가 만든 서버입니다.
* 해커는 악성 애플리케이션을 설치한 단말기에서 도청을 하기 위해 **Start** 버튼을 클릭합니다.
* 그럼, 이제 휴대전화의 마이크를 통해 모든 소리가 녹음됩니다.
* 그 후 해커는 **Stop** 버튼을 클릭해서 녹음된 파일을 전송받습니다.
* 그런 다음 해커는 녹음된 파일을 재생해서 어떤 소리가 녹음되어 있는지 확인합니다.
* {Image}
[[영상 바로 가기]](https://youtu.be/xh9gyT9lrpA)
* 이렇게 해커 및 범죄자는 피해자 주변의 소리를 언제 어디서든 들을 수가 있으며 이를 바탕으로 협박과 2차 피해를 줄 수 있습니다.

## 2. 위치 추적

* <span style="color:rgb(51, 51, 51);">다음은 GPS 권한입니다.</span>
* <span style="color:rgb(51, 51, 51);">보이스 피싱 범죄자들은 피해자가 자신들이 원하는 위치로 가고 있는지, 혹은 경찰서나 다른 곳으로 가고 있는지 확인하기 위해 GPS 데이터를 활용해서 실시간으로 피해자의 위치를 파악합니다.</span>
* <span style="color:rgb(51, 51, 51);">분석 결과 보이스 피싱 애플리케이션은 아래의 총 3가지의 권한으로 피해자의</span>
* 위치를 추적하는데 사용하였습니다<span style="color:rgb(51, 51, 51);">.
* {Image}
* 분석 결과, 위의 권한을 사용한 코드는 다음과 같습니다.
* {Image}
* 또한 추가로 분석한 결과, 위의 코드를 통해 피해자의 위치를 추척하고 추척한 위치 데이터를 DB에 저장하는 행위도 발견하였습니다.
* {Image}
* 아래의 데모 영상을 보시기 전에 잠깐 부가적인 설명을 하겠습니다.
* 보이스 피싱 범죄자들은 자신들의 웹 서버에서 **Start**를 클릭하여 피해자의 위치 정보를 수집합니다.
* **Start**를 클릭하면 피해자의 단말기(스마트폰)에서 현재 위치 정보를 DB 파일 또는 파일로 저장합니다.
* 해당 파일과 데이터로 현재 피해자의 위치를 알아냅니다.
* 따라서 데모 영상을 보여드리기 위해 운동 삼아 석촌 호수공원을 한 바퀴 걸었습니다. (실제 위치 정보를 수집하기 위해)
* 보이스 피싱 범죄자는 피해자의 위치가 궁금하여 **Start** 버튼을 클릭합니다.
* 피해자의 위치 정보는 실시간으로 보이스 피싱 범죄자들의 서버로 전송되어 사용자의 위치를 지도에 표시해 줍니다.
* 아래의 데모 영상을 보시면 쉽게 이해가 될 겁니다.
* {Image}
[[영상 바로 가기]](https://youtu.be/iUsvY4wiCJU)

## 3. 불법 촬영

* 보이스 피싱 애플리케이션을 설치할 당시 사진과 동영상에 대한 권한을 요구하였습니다.
* {Image}
* 위의 권한이 사진 및 동영상을 촬영하기 위한 카메라에 대한 권한입니다.
* 분석 결과, 제가 분석한 보이스 피싱 애플리케이션에서는 권한만 추가되어 있을 뿐 카메라 권한을 가지고 범죄에 활용한 코드는 존재하지 않았습니다.
* 하지만 생각해 보면 보이스 피싱 범죄자들은 피해자의 현재 장소 또는 사진 및 영상을 협박의 수단으로 활용할 수 있기 때문에 짧게 데모 영상을 만들어 봤습니다.
* 보이스 피싱 범죄자들은 자신들의 웹 서버에서 **Start** 버튼을 클릭합니다.
* **Start** 버튼을 클릭하면 카메라의 전면, 후면에 접근하여 각각 사진을 촬영한 다음 보이스 피싱 범죄자들의 서버로 전송하는 데모 영상입니다.
* 먼저 피해자는 평소처럼 유튜브를 시청하고 있었습니다.
* 이때 보이스 피싱 범죄자들은 앞에서 설명해 드린 카메라 권한이 있기 때문에 **Start** 버튼을 클릭해 원격에서 피해자의 카메라 전면과 후면에 접근하여 각각 사진을 촬영합니다.
* 그 후 범죄자의 서버로 촬영한 사진을 업로드하여 확인할 수 있습니다.
* {Image}
[[영상 바로 가기]](https://youtu.be/5IS_zQesG2c)  
* 위 데모 영상처럼 사진 촬영밖에 없지만 카메라 권한이 있기 때문에 동영상 촬영도 손쉽게 할 수 있습니다.

## 4. SMS 탈취

* 다음은 문자(SMS)에 접근할 수 있는 권한입니다.
* {Image}
  
* 사용자가 위의 권한을 허용한다면 애플리케이션에서 문자에 접근할 수 있습니다.
* 위의 권한으로 피해자 단말기에 존재하는 SMS에 접근하여 보낸 사람의 이름, 전화번호, 문자 내용, 시간 등 문자에 대한 대부분의 정보에 접근하여 데이터를 탈취하는 것을 확인할 수 있었습니다.
* 관련된 코드는 아래와 같습니다.
* {Image}
* SMS 데이터에 접근해서 저장된 이름(display_name) 또한 저장되는 것을 확인하였습니다.
* {Image}
* 이렇게 저장된 이름과 전화번호가 탈취된다면 피해자의 단말기에 저장된 수많은 사람도 보안 위협의 대상이 될 가능성이 존재합니다.
* 아래의 데모 영상은 수신자에게 오는 SMS를 실시간으로 보이스 피싱 범죄자들의 서버로 전송하는 데모 영상입니다.
* Sender는 수신자(피해자)에게 문자를 보냅니다.
* 이때 그림과 같이 인증 번호일 수도 있고, 중요한 내용을 담은 문자일 수 있습니다.
* {Image}
* 아래의 코드는 SMS 정보를 탈취하는 코드 중 일부입니다.
* 이렇게 새로운 SMS를 피해자가 수신하게 되면 보이스 피싱 범죄자들의 서버로 전송하도록 합니다.
* SMS 내용을 탈취하는 기능은 백그라운드에서 실행되며 SMS를 수신하고 발신할 때 보이스 피싱 범죄자들에게 똑같이 전송되게 됩니다.
* {Image}
* {Image}
[[영상 바로 가기]](https://youtu.be/Cex079bPAPQ)


## 5. 수신 및 발신 경로 변조와 차단

* 다음은 보이스 피싱 애플리케이션의 핵심인 수신 및 발신 전화 변조에 관한 내용에 관해서 설명해 드리겠습니다.
* 먼저 수신 및 발신 전화의 경로를 변조하기 위해서는 아래와 같이 전화와 관련된 권한이 필요합니다.
* {Image}
* 이를 설명해 드리기에 앞서 아래의 Youtube 영상을 잠깐 보고 오시겠습니다.
    * [https://www.youtube.com/watch?v=i73GuJWpROQ&t=25s](https://www.youtube.com/watch?v=i73GuJWpROQ&t=25s)
    * [https://www.youtube.com/watch?v=YTH-drhg0Hw&t=344s](https://www.youtube.com/watch?v=YTH-drhg0Hw&t=344s)
* 영상에서 보셨던 것처럼 언론과 기사에서는 '전화 가로채기'라는 기법으로 많이 소개되어 있습니다.
* 보이스 피싱 애플리케이션에 감염된 피해자가 확인을 위해 금융기관에 전화(발신)를 걸면 보이스 피싱 범죄자들이 수집한 전화번호 리스트에 있는지 없는지 판단한 후 없으면 정상적인 수신자에게 발신하게 됩니다.
* 하지만 범죄자들이 수집한 전화번호 리스트에 존재한다면 위 영상에서 보신 것처럼 자신들에게 발신이 오도록 전화번호를 변조합니다.
* 아래의 그림은 위의 설명을 이해하기 쉽게 도식화한 것입니다(그림에 나와있는 기관은 무관합니다).
* {Image}
* 하지만 제가 분석한 보이스 피싱 애플리케이션에서는 피해자가 발신할 때 자신들이 수집한 전화번호 리스트에 존재한다면 발신 자체를 하지 못하도록 차단하는 기법을 사용하였습니다.
* 아래의 그림은 현재 분석하는 보이스 애플리케이션에서 사용하는 기법을 이해하기 쉽도록 도식화한 것입니다.
* {Image}
* 수신과 발신 경로 변조 및 차단은 보이스 피싱 애플리케이션의 핵심이기 때문에 위 4가지 기법보다는 핵심을 조금 자세히 설명하려고 합니다.
* {Image}
* 위의 코드를 분석한 결과, `Intent`[[9]](https://developer.android.com/reference/android/content/Intent)를 통해 피해자의 발신 여부를 판단합니다.
* `Intent`는 애플리케이션 컴포넌트 간에 실행을 요청하는 메시지나 데이터를 전달하는 역할을 합니다.
* 예를 들어, 활동(Activity), 서비스(Service), 브로드캐스트 리시버(BroadcastReceiver) 등을 시작할 때 `Intent`를 사용합니다.
* intent.getAction() 메서드는 `Intent`에 설정된 action 문자열을 반환합니다.
* 이 문자열을 사용하여 `Intent`가 수행하려는 구체적인 작업이 "android.intent.action.NEW_OUTGOING_CALL"이라면 v3는 true가 됩니다.
* 이는 새로운 발신 전화가 시작됐음을 의미합니다.
* 새로운 발신 전화가 시작되었으면 intent.getStringExtra("android.intent.extra.PHONE_NUMBER")를 실행하여 발신하려는 전화번호를 `Intent`로부터 추출합니다.
* 아래의 코드는 발신 번호와 수집한 전화번호를 비교하기 위해 수집한 전화번호와 비교하는 코드입니다.
* {Image}
* 위의 코드는 allNoMap이라는 HashMap에 Kit.Z(context)이 반환하는 값을 저장합니다.
* 즉, Kit.Z() 메서드가 반환하는 값은 보이스 피싱 범죄자들이 수집한 전화번호를 의미합니다.
* AllNoBean allNoBean = (AllNoBean)allNoMap.get(number); 코드의 의미는 allNoMap이라는 수집된 번호에서 발신 전화번호가 있는지 확인하는 기능을 합니다.
* 만약 존재한다면 getCome() 메서드는 0을 반환하고 this.setResultData(null); 코드로 발신을 중단합니다.
* 발신을 중단한다는 의미는 발신 자체를 못 하게 막아버린다고 생각하시면 됩니다.
* 아쉽게도 C&C 서버에서 수집한 전화번호에 대한 데이터를 받아와야 하지만 현재 C&C 서버와 통신이 되지 않아 수집한 전화번호에 대한 데이터는 애플리케이션에 존재하지 않았습니다.
* 이제 데모 영상을 보시겠습니다.
* 먼저 피해자는 보이스 피싱 범죄자들에게 걸려 온 전화를 받고 확인차 금융위원회, 금융감독원, 금융권 등에 확인을 하기 위해서 전화합니다. (영상에서는 NHN Cloud 대표 전화번호)
* 이때 보이스 피싱 애플리케이션은 수집된 전화번호 리스트에서 발신한 번호가 존재한다면 정상적인 경로가 아닌 해커 또는 보이스 피싱 범죄자들에게 발신이 되도록 경로를 변조합니다.
* 피해자는 확인을 위해 금융권 등에 전화를 하였지만 실제로는 범죄자들에게 다시 전화를 걸게 되는 것입니다.
* 또한 통화 기록도 수정하여 실제 정상적으로 통화를 했다고 착각하게 만들어 안심시킵니다.
* {Image}
[영상보기](https://youtu.be/32bLJJcV4pU)</span>
* 여기까지 보이스 피싱 애플리케이션의 대표적인 악성 행위 5가지에 대해서 알아보았습니다.
* <span style="color:rgb(13, 13, 13);">이러한 행위들은 사용자의 개인정보를 노리거나 금전적인 손실을 초래할 수 있으므로, 각별한 주의가 필요합니다. </span>

# 마치며

* 개인적으로 이번 보이스 피싱 애플리케이션에 대한 분석을 진행하면서 많은 것을 배우고 느낀 시간이었습니다.
* 정보를 찾아보고 데이터를 분석하며, 최대한 많은 분들이 이해하기 쉬운 형태로 정리하는 과정 또한 좋은 경험이 되었는데요.
* 보이스 피싱, 그 영향력이 얼마나 큰 지에 대한 깊은 이해를 얻을 수 있었던 좋은 기회였습니다.
* 사실 힘든 것보다 매우 재밌었습니다.
* 특히 데모 영상을 만들기 위해 직접 애플리케이션과 서버, 웹 사이트를 개발해 보면서 개발자분들의 전문성과 노력에 대해 다시 한번 생각하는 시간이 되었습니다.
* 이번 보이스 피싱 애플리케이션 분석 내용을 통해 모바일 보안뿐만 아니라 보안에 대한 경각심이 조금이라도 생기셨다면 큰 보람을 느낄 것 같습니다.
* 끝으로, 기술의 발전이 무조건 좋은 것이 아니라, 우리에게 가져다주는 편리함과 동시에 우리가 직면할 수 있는 잠재적인 보안 위험성에 대해서도 한 번쯤은 생각해 보는 계기가 되었으면 좋겠습니다.
* 보이스 피싱 애플리케이션 분석 1편과 2편의 긴 내용을 읽어 주셔서 감사합니다.

# 참고 문헌

> [1] [Packet](https://developer.mozilla.org/ko/docs/Glossary/Packet)
> [2] [JSON](https://namu.wiki/w/JSON)
> [3] [AES](https://namu.wiki/w/AES)
> [4] [초기화 벡터](https://ko.wikipedia.org/wiki/%EC%B4%88%EA%B8%B0%ED%99%94_%EB%B2%A1%ED%84%B0)
> [5] [베이스64](https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464)
> [6] [https://www.youtube.com/watch?v=eapWmmBFK6s&t=533](https://www.youtube.com/watch?v=eapWmmBFK6s&t=533)
> [7] [파일 시그니처](https://namu.wiki/w/%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98)
> [8] [https://developer.android.com/guide/topics/manifest/manifest-intro?hl=ko](https://developer.android.com/guide/topics/manifest/manifest-intro?hl=ko)
> [9] [https://developer.android.com/reference/android/content/Intent](https://developer.android.com/reference/android/content/Intent)
